<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="wobenng的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wobenng的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wobenng的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>wobenng的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wobenng的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/《JavaScript标准参考教程》DOM概述笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hangbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wobenng的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/《JavaScript标准参考教程》DOM概述笔记/" itemprop="url">《JavaScript标准参考教程》DOM概述笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-03T22:12:24+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://javascript.ruanyifeng.com/dom/node.html" target="_blank" rel="external">参考链接1</a><br><a href="http://luopq.com/2015/11/30/javascript-dom/" target="_blank" rel="external">参考链接2</a></p>
<p></p><h3>什么是DOM？</h3><br>DOM全称文档对象模型 (Document Object Model)；它的作用是对结构化网页（即HTML文档）中的<strong>各类节点</strong>进行解析，根据<strong>节点之间的关系</strong>，形成<strong>树状结构的模型</strong>；网页的整体结构等同于DOM中的树状结构，然后JavaScript就可以通过操作DOM中的节点来对网页进行操作；<p></p>
<p>###组成DOM的节点类型有哪些？</p>
<blockquote>
<p>Document：整个文档树的顶层节点<br>DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;）<br>DocumentFragment：文档的片段<br>Element：网页的各种HTML标签（比如<body>、<a>等）<br>Attribute：网页元素的属性（比如class=”right”）<br>Text：标签之间或标签包含的文本<br>Comment：注释</a></body></p>
</blockquote>
<p><strong>以上的七个节点都是浏览器内置的Node对象的实例，继承了Node属性和方法；</strong></p>
<p>###DOM中节点之间的关系有哪些？</p>
<p>DOM中各个节点的关系是根据文档之间的节点关系形成的；文档中的节点存在以下关系：</p>
<blockquote>
<p>父节点关系（parentNode）：直接的那个上级节点<br>子节点关系（childNodes）：直接的下级节点<br>同级节点关系（sibling）：拥有同一个父节点的节点;</p>
</blockquote>
<p>如下图片所示：<br><img src="http://upload-images.jianshu.io/upload_images/9131983-5de54149cee2840b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>相邻的左右节点为同级节点，上下节点是父节点与子节点的关系；</p>
<p>###节点对象继承了Node对象的哪些属性？</p>
<p>#####一、和节点特征相关的属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:right">nodeName</th>
<th style="text-align:center">nodeType</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ELEMENT_NODE</td>
<td style="text-align:right">大写的HTML元素名</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">ATTRIBUTE_NODE</td>
<td style="text-align:right">属性名字</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:left">TEXT_NODE</td>
<td style="text-align:right">#text</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:left">COMMENT_NODE</td>
<td style="text-align:right">#comment</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:left">DOCUMENT_NODE</td>
<td style="text-align:right">#document</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:left">DOCUMENT_FRAGMENT_NODE</td>
<td style="text-align:right">#document-fragment</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:left">DOCUMENT_TYPE_NODE</td>
<td style="text-align:right">等同于DocumentType.name</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<p>1、<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2、```Node.nodeType```返回节点类型的常数值；</div><div class="line">3、```Node.nodeValue```返回一个字符串，表示当前节点本身的文本值，且该节点必须是Text节点或者Comment节点，其余节点返回null；该属性可读写；</div><div class="line">4、```Node.textContent```自动忽略当前结点内部的HTML标签，返回当前节点和它的所有后代节点的文本内容；该属性可读写；</div><div class="line">如：</div></pre></td></tr></table></figure></p>
<p>HTML部分</p>
<div id="example">这是一个<span>例子</span></div>

<p>JavaScript部分<br>document.getElementById(‘example’).textContent<br>//这是一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5、``` Node.baseURI ```返回一个字符串，表示当前网页的绝对路径。不同节点都可以调用这个属性，它们的值都是相同的；如果在网页中添加```&lt;base&gt;```标签，那么会返回```href```标签中的值；</div><div class="line">#####二、通过节点关系获得相关节点的属性</div><div class="line">6、```Node.nextSibling```返回紧跟在当前节点后面的同级节点，没有则返回null；该属性的值还包括同级的text节点和comment节点，*所以在HTML中，相邻的两个同级的元素会利用回车重启一行，那么上一行的元素```Node.nextSibling```不会是下一行的同级元素，而是回车；*</div><div class="line">7、```Node.previousSibling```返回紧跟在当前节点前面的同级节点，没有则返回null；其余同理于```Node.nextSibling```；</div><div class="line">8、```Node.firstChild，Node.lastChild```分别返回当前节点的第一个节点和最后一个节点，如果没有则返回null；*注意除了HTML元素节点，还包括text和comment节点；*</div><div class="line">9、```Node.parentElement```返回当前节点的父节点；父节点只是element节点，根节点；否则返回null;*注意在IE浏览器中，只有Element节点才有该属性，其他浏览器则是所有类型的节点都有该属性*；</div><div class="line">10、```Node.parentNode```返回当前节点的父节点；父节点通常是element节点，根节点，#document，#document父节点为null；</div><div class="line">11、```Node.childNodes```返回一个NodeList集合，成员包括HTML元素节点，text和comment节点，如果没有子节点，则返回一个空的NodeList集合；NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中；</div><div class="line">###节点对象继承了Node对象的哪些方法？</div><div class="line">#####一、用于节点增插删改的方法</div><div class="line">1、```Node.appendChild()```方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点；*该方法的当前节点只是element节点，参数可以接受其他节点*；</div><div class="line">2、```Node.insertBefore()```方法用于将某个节点插入当前节点内部的指定位置。它接受两个参数，第一个参数是所要插入的节点，第二个参数是当前节点内部的一个子节点，新的节点将插在这个子节点的前面；如果第二个参数为null，则新节点将插在当前节点内部的最后位置，变成最后一个子节点。该方法返回被插入的新节点。*该方法中的当前节点必须是element节点，两个参数可以是文本节点；*</div><div class="line">3、```Node.removeChild()```方法接受一个子节点作为参数，用于从当前节点移除该子节点。它返回被移除的子节点。*该方法中的当前节点必须是element节点，参数可以是文本节点；*</div><div class="line">4、```Node.replaceChild()```将一个新的节点，替换当前节点的某一个子节点。它接受两个参数，第一个参数是用来替换的新节点，第二个参数将要被替换走的子节点。它返回被替换走的那个节点。*该方法中的当前节点必须是element节点，参数可以是文本节点；*</div><div class="line">5、```Node.cloneNode()```方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是false，即不克隆子节点。需要注意的是，克隆一个节点，会拷贝该节点的所有属性,但是会丧失addEventListener方法和on-属性（即node.onclick = fn），添加在这个节点上的事件回调函数。*该方法可以用于文本节点的克隆；*</div><div class="line">6、```Node.normalize()```将多次插入当前节点的Text节点在去除空的文本节点后合并成一个节点；也就是说在该方法前插入几次文本节点，那么该节点的childNodes.length就会显示几次，在该方法后，将多次插入变为一次。</div><div class="line">#####二、用于节点关系判断的方法</div><div class="line">7、```Node.hasChildNodes()```方法返回一个布尔值，表示当前节点是否有子节点。当前节点如果是文本节点也会返回false；</div><div class="line">8、```Node.contains()```方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点。如果将自己作为参数传入，也会返回true;</div><div class="line">9、```Node.isEqualNode()```方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</div><div class="line">###只有Element节点、Document节点和DocumentFragment节点拥有的属性</div><div class="line">1、```children```返回一个动态的HTMLCollection集合，由当前节点的所有**Element子节点**组成。要和```Node.childNodes```区分开；</div><div class="line">2、```firstElementChild```和```lastElementChild```分别返回当前节点的第一个Element子节点和最后一个Element节点，如果不存在任何Element子节点，则返回null。</div><div class="line">3、```childElementCount```返回当前节点的所有Element子节点的数目。</div><div class="line">###只有Element节点、Document节点和DocumentFragment节点拥有的方法</div><div class="line">1、```remove()```方法用于移除当前节点。如：```element.remove()```就是移除了```element```节点；</div><div class="line">2、```before()```和```after()```分别在当前节点的前面和后面插入一个同级节点；要插入的节点就是方法中的参数；</div><div class="line">3、```replaceWith()```方法使用参数指定的节点，替换当前节点;</div><div class="line">***</div><div class="line">###除了继承Node节点的属性和方法，各个节点对象自身又有什么属性和方法？</div><div class="line">***</div><div class="line">####document节点的属性</div><div class="line">#####一、获取相关节点的属性</div><div class="line">1、```document.documentElement```对于HTML网页，该属性返回&lt;html&gt;节点。</div><div class="line">2、```document.body，document.head```返回当前文档的```&lt;head&gt;```节点和```&lt;body&gt;```节点。*这两个属性可写，如果对其写入一个新的节点，会导致原有的所有子节点被移除。*</div><div class="line">3、```document.activeElement```返回当前文档中获得焦点的那个元素。</div><div class="line">4、```document.links，document.forms，document.images，document.embeds```分别返回对应标签的HTMLCollection对象实例。</div><div class="line">5、```document.scripts，document.styleSheets```分别返回脚本和样式表的HTMLCollection对象实例。</div><div class="line">#####二、返回文档信息的属性</div><div class="line">6、```document.documentURI，document.URL```返回字符串，表示当前文档的网站；在不对```&lt;base&gt;```标签中的```href```属性修改的前提下，```Node.baseURI```的值和前两者的值是一样的；</div><div class="line">7、```document.domain```返回当前文档的域名。比如某网址是http://www.example.com/hello.html ，那么该属性返回的值就是www.example.com;</div><div class="line">8、```document.location```属性返回location对象，提供了当前文档的URL信息。</div><div class="line">```document.location = &apos;http://www.example.com&apos;;```将新的网址赋值给location对象，网页就会自动跳转到新网址。```document.location = &apos;page2.html&apos;;```也可以指定相对URL。```document.location = &apos;#top&apos;;```如果指定的是锚点，浏览器会自动滚动到锚点处。</div><div class="line">**location对象又有以下属性：**</div><div class="line"></div><div class="line">&gt;// 当前网址为 http://user:passwd@www.example.com:4097/path/a.html?x=111#part1</div><div class="line">document.location.href // &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;</div><div class="line">document.location.protocol // &quot;http:&quot;</div><div class="line">document.location.host // &quot;www.example.com:4097&quot;</div><div class="line">document.location.hostname // &quot;www.example.com&quot;</div><div class="line">document.location.port // &quot;4097&quot;</div><div class="line">document.location.pathname // &quot;/path/a.html&quot;</div><div class="line">document.location.search // &quot;?x=111&quot;</div><div class="line">document.location.hash // &quot;#part1&quot;</div><div class="line">document.location.user // &quot;user&quot;</div><div class="line">document.location.password // &quot;passwd&quot;</div><div class="line"></div><div class="line">**location对象又有以下方法：**</div><div class="line"></div><div class="line">&gt; // 跳转到另一个网址</div><div class="line">document.location.assign(&apos;http://www.google.com&apos;)</div><div class="line">// 优先从服务器重新加载</div><div class="line">document.location.reload(true)</div><div class="line">// 优先从本地缓存重新加载（默认值）</div><div class="line">document.location.reload(false)</div><div class="line">// 跳转到新网址，并将取代掉history对象中的当前记录</div><div class="line">document.location.replace(&apos;http://www.google.com&apos;);</div><div class="line"></div><div class="line">9、```document.referrer```属性返回一个字符串，表示当前文档的访问来源。如果无法获取或者用户是直接键入网址的，那么返回null;</div><div class="line">10、```document.title```属性返回当前文档的标题，该属性是可写的。</div><div class="line">11、```document.readyState```属性返回当前文档的状态;当值为</div><div class="line">```loading```表示加载HTML阶段和执行JS阶段；当值为```interactive```时，HTML文档解析完成；当值变为```complete```时，图片、样式表、字体文件等外部资源加载完成；</div><div class="line">####document节点的方法</div><div class="line">#####一、读写相关的方法</div><div class="line">1、```document.open()```和```document.close()```用于打开或者关闭一个文档；</div><div class="line">2、```document.write()，document.writeln()```用于在页面open()的时候，向其写入内容，如果内容已经解析完成，会擦除原先的内容，加入后来添加的内容；一旦页面close(),就不能向其写入内容；两者的区别是多次调用该方法时，后者会换行，而前者不会；</div><div class="line">#####二、查询相关节点的方法</div><div class="line">3、```document.querySelector()，document.querySelectorAll()</div></pre></td></tr></table></figure></p>
<p>接受一个CSS选择器作为参数，返回匹配该选择器的元素节点。前者返回匹配到的第一个元素节点，后者返回所有匹配到的元素节点；如果没有，两者都返回null；这两个方法的参数可以时多个，用逗号分隔，返回参数中的所有元素节点；<br>*要注意的是<br>3.1如果是元素标签作为参数，该参数必须是大写的元素标签；<br>3.2参数不能是伪元素；<br>3.3<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">3.4最后，这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。*</div><div class="line">4、```document.getElementsByTagName()```返回一个类似数组的HTMLCollection对象，包含所有对应的HTML元素；如果没有则返回一个空集；*不同于```document.querySelectorAll()```方法获取HTML元素，这个方法可以实时反映HTML文档的变化。但是这个方法同样也可以在document对象上调用，也可以在任何元素节点上调用。*</div><div class="line">5、```document.getElementsByClassName()```方法返回一个类似数组的对象（HTMLCollection实例对象),成员包括class等于参数的所有元素，元素的变化实时反映在返回结果中。如果想要返回同时有两个class名字的元素，只需要两个参数中间有一个空格；*可以在任何元素节点上调用。*</div><div class="line">6、```document.getElementById()```返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。</div><div class="line">#####三、生成相关节点</div><div class="line">7、```document.createElement(),document.createTextNode()```生成HTML元素节点和文本节点；</div><div class="line">8、```document.createAttribute()```方法生成一个新的属性对象节点，并返回它。</div><div class="line">9、```document.hasFocus()```方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</div><div class="line">#####四、事件相关方法</div><div class="line">10、```document.addEventListener()，document.removeEventListener()</div></pre></td></tr></table></figure></p>
<hr>
<p>####Element节点的属性</p>
<p>#####一、特征相关的属性<br>1、<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">2、```Element.className，Element.classList```返回当前节点```class```属性的值，前者返回字符串形式的值，每个值之间隔一个空格；后者返回一个类似数组的对象，该对象的length属性（只读）返回当前元素的class数量；该对象的还包括以下方法：</div><div class="line"></div><div class="line">&gt; add()：增加一个class。</div><div class="line">remove()：移除一个class。</div><div class="line">contains()：检查当前元素是否包含某个class。</div><div class="line">toggle()：将某个class移入或移出当前元素。</div><div class="line">item()：返回指定索引位置的class。</div><div class="line">toString()：将class的列表转为字符串。</div><div class="line"></div><div class="line">3、```Element.innerHTML```返回元素包含的HTML代码（不包括自身），该属性可读写，所以可以向元素中间插入HTML代码，不像```Node.textContent```适用于插入文本，会忽略HTML标签```；如果将```Element.innerHTML```的设置为空，则删除当前节点所包含的所有内容；</div><div class="line">4、```Element.outerHTML```也是返回HTML代码，不同于```Element.innerHTML```，它还返回自身标签，并且双引号或者单引号会被转义；该属性也可读写,但是值改变显示的效果，而对于HTML原来文档中的内容不做修改；</div><div class="line">#####二、获取元素高度，宽度，相对于浏览器视口坐标，相对于网页文档坐标的属性；</div><div class="line">1、```Element.offsetHeight，Element.offsetWidth```返回元素的高度（包括padding,border,以及滚动条）。*该方法用于求网页高度和宽度的时候是不包括滚动条的；*</div><div class="line">2、```Element.scrollHeight，Element.scrollWidth```返回元素的高度（包括padding）。</div><div class="line">3、```Element.clientHeight，Element.clientWidth```返回元素节点可见部分的高度（包括padding）。</div><div class="line">4、```Element.scrollLeft，Element.scrollTop```分别表示网页元素的水平滚动条向右侧滚动的像素数量和网页元素的垂直滚动条向下滚动的像素数量。</div><div class="line">5、```Element.offsetLeft，Element.offsetTop```分别返回当前元素左上角相对于Element.offsetParent节点的水平位移和垂直位移；这里的Element.offsetParent是当前 HTML 元素的最靠近的、并且 CSS 的position属性不等于static的上层元素。如果没有的话就是相对于body，也就是说是相对于整张网页的坐标；如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），则offsetParent属性返回null。如果元素是float，则offsetParent为最近的父元素；</div></pre></td></tr></table></figure></p>
<p>//求网页的高度<br>document.documentElement.scrollHeight<br>//求网页宽度<br>document.documentElement.scrollWidth</p>
<p>// 视口高度<br>window.innerHeight // 包括滚动条<br>document.documentElement.clientHeight // 不包括滚动条</p>
<p>// 视口宽度<br>window.innerWidth // 包括滚动条<br>document.documentElement.clientWidth // 不包括滚动条</p>
<p>// 网页元素左上角的视口横坐标<br>Element.getBoundingClientRect().left</p>
<p>// 网页元素左上角的视口纵坐标<br>Element.getBoundingClientRect().top</p>
<p>// 网页元素左上角的网页横坐标<br>Element.getBoundingClientRect().left + document.documentElement.scrollLeft</p>
<p>// 网页元素左上角的网页纵坐标<br>Element.getBoundingClientRect().top + document.documentElement.scrollTop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#####三、获取相关节点的属性</div><div class="line">使用Node或者Document中获得相关元素的方法就可以获得，下面说的是上面没有的属性</div><div class="line">1、```Element.nextElementSibling，Element.previousElementSibling```返回当前HTML元素节点的后一个同级HTML元素节点，如果没有则返回null。这个要和```Node.nextSibling,Node.previousSibling```区分开来；</div><div class="line">####Element节点方法</div><div class="line">#####一、操作属性的方法</div><div class="line"></div><div class="line">&gt; Element.getAttribute()：读取指定属性</div><div class="line">Element.setAttribute()：设置指定属性</div><div class="line">Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性</div><div class="line">Element.removeAttribute()：移除指定属性</div><div class="line"></div><div class="line">#####二、其他方法</div><div class="line">1、```Element.matches```方法返回一个布尔值，表示当前元素是否匹配给定的CSS选择器。</div><div class="line">2、```Element.insertAdjacentHTML()```法解析HTML字符串，然后将生成的节点插入DOM树的指定位置。该方法接受两个参数，第一个是指定位置，第二个是待解析的字符串。</div><div class="line"></div><div class="line">&gt; beforebegin：在当前元素节点的前面。</div><div class="line">afterbegin：在当前元素节点的里面，插在它的第一个子元素之前。</div><div class="line">beforeend：在当前元素节点的里面，插在它的最后一个子元素之后。</div><div class="line">afterend：在当前元素节点的后面。</div><div class="line"></div><div class="line">3、```Element.getBoundingClientRect()</div></pre></td></tr></table></figure>
<blockquote>
<p>x：元素左上角相对于视口的横坐标<br>left：元素左上角相对于视口的横坐标，与x属性相等<br>right：元素右边界相对于视口的横坐标（等于x加上width）<br>width：元素宽度（等于right减去left）<br>y：元素顶部相对于视口的纵坐标<br>top：元素顶部相对于视口的纵坐标，与y属性相等<br>bottom：元素底部相对于视口的纵坐标<br>height：元素高度（等于y加上height）</p>
</blockquote>
<hr>
<p>####Text节点的方法<br>1、</p>
<blockquote>
<p>// HTML代码为<br>// </p><p>Hello World</p><br>var pElementText = document.querySelector(‘p’).firstChild;<br>//在字符串尾部添加，页面显示 Hello World!<br>pElementText.appendData(‘!’);<br>// 删除字符串，第一个参数是开始删除的下标位置，包括该开始位置；第二个参数是删除的长度，页面显示 Hello W<br>pElementText.deleteData(7,5);<br>// 插入字符串，第一个参数是插入下标，第二个参数是要插入的字符串； 页面显示 Hello WHello<br>pElementText.insertData(7,’Hello ‘);<br>//替换字符串，第一个参数是要替换的位置下标，第二个参数是要替换的字符串长度，第三个是替换的字符串；页面显示 Hello WWorld<br>pElementText.replaceData(7,5,’World’);<br>// 获取字符串，第一个参数是获取的起始位置下标；第二个参数是要获取的字符串长度；页面显示不变，返回”World “<br>pElementText.substringData(7,10);<p></p>
</blockquote>
<p>2、<code>remove</code>是移除当前的文本节点；<br>3、<code>splitText()，normalize()</code>分别是分割字符串和合并字符串；前者是字符串节点调用该方法，参数是分隔的起始位置下标；后者是包含该文本节点的element节点调用该方法；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/20/那些年，我们遇到的bug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hangbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wobenng的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/那些年，我们遇到的bug/" itemprop="url">那些年，我们遇到的bug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-20T14:55:45+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###如何取去除inline-block和inline元素之间的空隙</p>
<p>######问题描述：<br>现有以下HTML代码，导致其中的<code>canvas</code>元素出现间隙；HTML部分如下：</p>
<pre><code>    &lt;div style=&quot;background-color:gray;&quot;&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:red;&quot; &gt;&lt;/canvas&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:blue;&quot;&gt;&lt;/canvas&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:green;&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
</code></pre><p>最后出现下面的现象：<br><img src="http://upload-images.jianshu.io/upload_images/9131983-fc4fd5f63719621f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到相邻<code>canvas</code>之间出现了空隙，就连下面也出现了空隙；然后找到了下面这个链接：<a href="https://stackoverflow.com/questions/5078239/how-to-remove-the-space-between-inline-block-elements#" target="_blank" rel="external">How to remove the space between inline-block elements?</a>也就是说<code>inline-block</code>和<code>inline</code>属性值会出现空隙；那么看一下<code>canvas</code>是不是行内元素呢？如下截图：<br><img src="http://upload-images.jianshu.io/upload_images/9131983-68be7a5eb9f372e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>的确是行内元素，按照链接中给出的解决方案如下：</p>
<p>######1.方案一：</p>
<pre><code>&lt;div style=&quot;background-color:gray;&quot;&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:red;&quot; id=&apos;canvas&apos;&gt;&lt;/canvas
    &gt;&lt;canvas width=300 height=20 style=&quot;background-color:blue;&quot;&gt;&lt;/canvas
    &gt;&lt;canvas width=300 height=20 style=&quot;background-color:green;&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
</code></pre><p>可以看到效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/9131983-060c58296ba9910c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>左右空隙没有了，但是上下还是有空隙的；又或者时链接中的其他方法，通过修改HTML只能消除左右之间的空隙，但不能消除上下的空隙；</p>
<p>######2.方案二：</p>
<pre><code>    &lt;div style=&quot;background-color:gray;font-size:0px;&quot;&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:red;&quot; id=&apos;canvas&apos;&gt;&lt;/canvas&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:blue;&quot;&gt;&lt;/canvas&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:green;&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
</code></pre><p>修改父元素的<code>font-size:0px;</code>来消除上下空隙，效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/9131983-b0d45b35a718d144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>######3.方案三：</p>
<pre><code>        &lt;div style=&quot;background-color:gray;display:flex;&quot;&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:red;&quot; id=&apos;canvas&apos;&gt;&lt;/canvas&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:blue;&quot;&gt;&lt;/canvas&gt;
    &lt;canvas width=300 height=20 style=&quot;background-color:green;&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
</code></pre><p>为父元素添加<code>display:flex</code>，不用设置其它属性就可以消除空隙；<code>canvas</code>也会变成块元素；效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/9131983-b0d45b35a718d144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>2017.11.20</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hangbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wobenng的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/排序/" itemprop="url">排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-31T14:58:09+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b><a href="http://bubkoo.com/tags/algorithm/" target="_blank" rel="external">各种排序原文链接</a></b><br><b><a href="http://zh.visualgo.net/en/sorting" target="_blank" rel="external">排序动态效视频</a></b></p>
<hr color="gray">

<p><b>冒泡排序</b></p>
<pre><code>function bubbleSort(array){
    for(var i=1;i&lt;array.length;i++){
        for(var j=0;j&lt;array.length-1;j++){
            if(array[j]&gt;array[j+1]){
                var temp=array[j+1];
                array[j+1]=array[j];
                array[j]=temp;
            }
        }
    }
    return array; 
}
</code></pre><p><b>插入排序</b></p>
<pre><code>function insertionSort(array){
    for(var i=1;i&lt;array.length;i++){
        for(var j=i;j&gt;0;j--){
            if(array[j]&gt;array[j-1]){
                var temp=array[j-1];
                    array[j-1]=array[j];
                    array[j]=temp;
            }
        }
    }
    return array; 
}
</code></pre><p><b>选择排序</b></p>
<pre><code>function selectionSort(array){
    for(var i=0;i&lt;array.length-1;i++){
        var minIndex=i;
        var minValue=array[i];
        for(var j=i+1;j&lt;array.length;j++){
            if(array[j]&lt;minValue){
                minIndex=j;
                minValue=array[j];
            }
        }
        var temp=array[i];
        array[i]=minValue;
        array[minIndex]=temp;
    }
    return array;
}
</code></pre><p><b>桶排序</b></p>
<pre><code>function bucketSort(array) {
    var bucket = [], // 正数桶
        negativeBucket = [], // 负数桶
        result = []; //结果桶
    // 入桶
    for (var i = 0; i &lt; array.length; i++) {
        if (array[i] &lt; 0) {
            abs = Math.abs(array[i]);
            if (!negativeBucket[abs]) {
                negativeBucket[abs] = [];
            }
            negativeBucket[abs].push(array[i]);
        } else {
            if (!bucket[array[i]]) {
                bucket[array[i]] = [];
            }
            bucket[array[i]].push(array[i]);
        }
    }
    // 出桶
    /* 注意这里的length是不是按数组个数定的，是数组下标的最大值加1；
    不论中间是不是缺少其他连续的数字,所以在下面还增加了一个数组是否存在的判断；*/
    for (var i = negativeBucket.length - 1; i &gt;= 0; i--) {
        if (negativeBucket[i]) {
            for (var j = 0; j &lt; negativeBucket[i].length; j++) {
                result.push(negativeBucket[i][j]);
            }
        }
    }
    for (var i = 0; i &lt; bucket.length; i++) {
        if (bucket[i]) {
            for (var j = 0; j &lt; bucket[i].length; j++) {
                result.push(bucket[i][j]);
            }
        }
    }
    return result;
}
</code></pre><p><b>快速排序</b></p>
<pre><code>function quickSort(array) {　　
    if (array.length &lt;= 1) {
        return array;     
    }　　
    var pivotIndex = Math.floor(array.length / 2);
    var pivot = array.splice(pivotIndex, 1)[0];
    var left = [];　　
    var right = [];　　
    for (var i = 0; i &lt; array.length; i++) {　　　　
        if (array[i] &lt; pivot) {　　　　　　
            left.push(array[i]);　　　　
        } else {　　　　　　
            right.push(array[i]);　　　　
        }　　
    }
    //将函数开始处满足条件的数组作为quickSort函数的返回值进行组合　　
    return quickSort(left).concat([pivot], quickSort(right));
}
</code></pre><p><b>堆排序</b></p>
<pre><code>function heapSort(array) {
    function swap(array, i, j) {
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
    function maxHeapify(array, index, heapSize) {
      var iMax,
        iLeft,
        iRight;
      while (true) {
        iMax = index;
        iLeft = 2 * index + 1;
        iRight = 2 * (index + 1);
        if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) {
          iMax = iLeft;
        }
        if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) {
          iMax = iRight;
        }
        if (iMax != index) {
          swap(array, iMax, index);
          index = iMax;
        } else {
          break;
        }
      }
    }
    function buildMaxHeap(array) {
      var i,
        iParent = Math.floor(array.length / 2) - 1;
      for (i = iParent; i &gt;= 0; i--) {
        maxHeapify(array, i, array.length);
      }
    }
    function sort(array) {
      buildMaxHeap(array);
      for (var i = array.length - 1; i &gt; 0; i--) {
        swap(array, 0, i);
        maxHeapify(array, 0, i);
      }
      return array;
    }
    return sort(array);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/《CSS揭秘》笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hangbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wobenng的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/《CSS揭秘》笔记/" itemprop="url">《CSS揭秘》笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-31T11:07:53+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: 《CSS揭秘》笔记<br>date: 2017-10-16 14:06:33</p>
<h2 id="tags-CSS笔记"><a href="#tags-CSS笔记" class="headerlink" title="tags: CSS笔记"></a>tags: CSS笔记</h2><p></p><h3><strong>七、伪随机背景</strong></h3><p></p>
<p></p><h4><em>问题:重复背景很呆板,如何让背景图片看起来更自然</em></h4><p></p>
<p></p><h4><em>解决方法:</em></h4><p></p>
<pre>
background:white;
background-image:linear-gradient(90deg,#fb3 10px,transparent 0),<br>                 linear-gradient(90deg,#ab4 20px,transparent 0),<br>                 linear-gradient(90deg,#655,20px,transparent 0);
background-size:80px 100%,60px 100%,40px 100%;</pre>

<p><div align="center"><img src="http://img.blog.csdn.net/20171016152152129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br></p>
<p></p><p><strong>注意:应将图片间隔最大的放在最顶层,即background-image的最上面,以免重复规律被察觉.实际上这张图片是每240px重复一次,240px是80px,60px,40px的最小公倍数</strong></p><p></p>
<p></p><p>可以看出最小公倍数越大,那么重复的频率就越低,背景图案也就越真实.所以在选取背景图片尺寸时,应选择质数,三个质数相乘,最小公倍数就会很大,比如按书中所讲,选择41,61,83,就会得到如下背景图:</p><p></p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171016163435257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%"></div><br></p>
<p></p><p><strong>END</strong></p><p></p>
<p></p><p><em>17.10.16</em></p><hr color="gray"><p></p>
<p></p><h3><strong>八、连续得到图像边框</strong></h3><p></p>
<p></p><h4><em>问题:让背景图片或图案成为边框</em></h4><p></p>
<p></p><h4><em>解决方法：</em></h4><p></p>
<p></p><p></p>
<p><pre><br>.someclass{<br>    padding:1em;<br>    border:1em solid transparent;<br>    background:linear-gradient(white,white),url(XXX.jpg);<br>    background-size:cover;<br>    background-clip:padding-box,border-box;<br>}</pre><br>只用在一个元素上使用背景图叠加背景渐变，再将上一层白色背景渐变的背景填充从内边距开始，边框透明，就能将下一层从边框开始填充的背景图片从透明边框出透出；除了透出背景图，还可以透出渐变背景，只要将最顶层的背景边框设置成透明，填充色从内边距开始，如下：</p>
<p><pre><br>.someclass{<br>    padding: 1em;</pre></p>
<pre><code>border: 1em solid transparent;

background-image:linear-gradient(white,white),

                 repeating-linear-gradient(-45deg,

                 red 0,red %,
                 transparent 0,transparent 25%,
                 #58a 0,#58a 37.5%,
                 transparent 0,transparent 50%;)
background-clip: padding-box,border-box;
background-size:cover;
</code></pre><p>}<br>如图<br></p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171017172701872?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="30%" height="30%"></div><br><b>通过改变<code>padding</code>来改变白色背景大小，通过改变<code>border</code>来改变边框粗细，通过改变<code>background-size</code>来改变渐变色的粗细；</b><br><br>还可以将<code>animation</code>和上面的方法结合起来形成蚂蚁行军的动态效果：<br></p>
<p><pre><br>@keyframes{to{background-position:100%;}}<br>.someclass{<br>    padding:1em;<br>    border:1px solid transparent;<br>    background:linear-gradient(white,white);<br>    repeating-gradient(-45deg,white 0,white 12.5%,<br>                       black 0,black 25%,<br>                       white 0,white 37.5%,<br>                       black 0,black 50%);<br>    background-size:10px,10px;<br>    animation{ants 12s linear infinite}<br>}<br></pre><br>以下是静止的图片截图</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171017200630275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="30%" height="30%"></div><br><b><code>background-position</code>的值改变动画的速度</b><hr color="gray"></p>
<p></p><h3><strong>九、自适应的椭圆</strong></h3><p></p>
<p></p><h4><em>问题：如何将矩形变成多种椭圆形</em></h4><p></p>
<p></p><h4><em>解决方法:</em></h4><br>假设矩形的宽和高为<b>W</b>和<b>H</b>,那么形状如下图：<div align="center"><br><img src="http://img.blog.csdn.net/20171018114238766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br>利用<code>border-radius：50% / 50%</code>把矩形变成圆形，如果是长方形就会变成椭圆形，实现原理如下：<br><br>50%确定了水平和垂直的圆心都在矩形中央，且四个角都变成圆角，再根据矩形的宽和高决定是椭圆还是圆；如下图所示:<p></p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171018151036324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br>同理<b>只有上半部分是二分之一的椭圆</b>分析如下，只有上半部分为圆形，所以圆心在矩形下边框的中点，<code>border-radius</code>的值水平是50%，垂直是100%，但是因为只有左上角和右上角有弧度且半径由高度决定，所以<code>border-radius:50%/100% 100% 0 0;</code><br><br><b>只有左半部分是二分之一的椭圆</b>分析如下，圆心在矩形右边框的中点，code&gt;border-radius的值水平是100%，垂直是50%，但是因为只有左上角和左下角有弧度且半径以宽度决定，所以<code>border-radius:100% 0 0 100%/50%;</code><br><br><b>只有左上角是四分之一的椭圆</b>分析如下，圆心在矩形的右下角，code&gt;border-radius的值水平是100%，垂直是100%，但是因为只有左上角有弧度且半径（即椭圆长半轴和短半轴）由高度和宽度共同决定，所以<code>border-radius:100% 0 0 0/100% 0 0 0;</code>更简单的写法是：<code>border-radius:100% 0 0 0;</code><hr color="gray"></p>
<p></p><h3><strong>十、平行四边形</strong></h3><p></p>
<p></p><h4><em>问题：如何将普通块状按钮变成平行四边形按钮,但是保持按钮里面的内容不变</em></h4><p></p>
<p></p><h4><em>解决方法:</em></h4><p></p>
<p><pre><br>.button{<br>    position:relative;<br>    width:150px;<br>    height:75px;<br>   }<br>   .button:before{<br>       content:””;<br>       position:absolute;<br>       top:0;<br>       left:0;<br>       bottom:0;<br>       right:0;<br>       background-color:yellow;<br>       z-index:-1;<br>       transform:skew(45deg);<br>   }</pre><br>   如下图所示：<br><br>   <div align="center"><img src="http://img.blog.csdn.net/20171018194105994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><hr color="gray"></p>
<p></p><h3><strong>十一、菱形图片</strong></h3><p></p>
<p></p><h4><em>问题：如何实现菱形图片</em></h4><p></p>
<p></p><h4><em>解决方法</em></h4><p></p>
<p><pre><br>.parent{<br>    width:300px;<br>    height:300px;<br>    transform:rotate(45deg);<br>    overflow:hidden;<br>}</pre></p>
<p>/*424px是.parent的谢贤长度，因为.parent旋转45度，为了使图片能全部填充.parent，所以要将img的宽度设置为斜边长度；</p>
<p>.parent&gt;img{<br>    width:424px;<br>    height:424px;<br>    transform:rotate(45deg);<br>}<br><br>但是如下图所示，会存在问题：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171018202538279?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br>上面的一角为什么会缺少呢？因为你将图片扩大，其实是将图片往两边扩大，往下方扩大，但是不会往上扩大，也就是说图片的位置还是不动的，宽度扩大了，下部分扩大了，导致上面部分缺角；那么最好的办法就是将图片按中心扩大，这样可以填充上面的缺角,如下所示：<br></p>
<p><pre><br>.parent{</pre></p>
<pre><code>width:300px;

height:300px;

transform:rotate(45deg);

overflow:hidden;
</code></pre><p>}<br>/<em>1.4=424/300  424是斜边长度</em>/<br>.parent&gt;img{</p>
<pre><code>width:100%;

height:100%;

transform:rotate(45deg) scale(1.4);
</code></pre><p>}<br><br>    图片如下所示：<br>    <div align="center"><img src="http://img.blog.csdn.net/20171018205104513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br>除了上面一种方法还有下面一种方法，如下:</p>
<p><pre><br>img{<br>   clip-path: polygon(50% 0,100% 50%,50% 100%,0 50%);<br>}<br>/<em>图片左上角X和Y的坐标是0，0，由此可见菱形图片四个角的坐标分别为（从上边框开始）：50% 0，100% 50%，50% 100%，0 50%；</em>/<br></pre><hr color="gray"></p>
<p></p><h3><strong>十二、切角效果</strong></h3><p></p>
<p></p><h4><em>问题：如何让元素由缺口</em></h4><p></p>
<p></p><h4><em>解决方法：</em></h4><p></p>
<p><pre><br>    .someclass{<br>    background:linear-gradient(-45deg,transparent 30px,#58a 0)<br>    }<br></pre><br>可以看到如下图所示：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171018220829436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br>但是如果我想要四个缺角呢？如下代码：</p>
<p><pre><br>    .someclass{<br>        background: linear-gradient(135deg,transparent 15px,#58a 0)top left,<br>        linear-gradient(-135deg,transparent 15px,#58a 0)top right,<br>        linear-gradient(45deg,transparent 15px,#58a 0)bottom left,<br>        linear-gradient(-45deg,transparent 15px,#58a 0)bottom right;<br>        background-size: 50% 50%;<br>        background-repeat:no-repeat;<br>    }<br></pre><br>如下图所示：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171018223422192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><hr color="gray"></p>
<p></p><h3><strong>十三、梯形标签页</strong></h3><p></p>
<p></p><h4><em>问题：如何生成梯形标签页</em></h4><p></p>
<p></p><h4><em>解决方法：</em></h4><p></p>
<p><pre><br>.first{<br>    margin: auto;<br>    position: relative;<br>    top: 50px;<br>    color:white;<br>    text-align: center;<br>    line-height: 20px;<br>    padding:15px 0px;<br>    width: 300px;<br>}<br>.first::before{<br>    content:””;<br>    position: absolute;<br>    top: 0;<br>    right: 0;<br>    bottom: 0;<br>    left: 0;<br>    z-index: -1;<br>    background: #58a;<br>    transform: perspective(.5em) rotateX(5deg) scaleY(2.5);<br>    transform-origin: bottom;<br>    border-radius: 0.5em 0.5em 0 0;<br>}<br></pre><br>如果只是对.first元素使用<code>perspective(.5em) rotateX(5deg)</code>,会连元素内部的文本也发生变形,所以采用伪元素，保持文本不变。默认变形是以中心轴为变形轴，但是会使元素下方扩大边界以外，所以利用<code>transform</code>可以改变旋转轴，以底线为旋转轴，下方就不会扩大，只会缩小上方，但是上方缩小的太小了，如果元素中心有文本，那么文本就因为上方变成梯形而高度变小而变的不是居中了，这时利用<code>scaleY()</code>进行扩大，并且以底线为中心，那么上方经过调整能扩大到使文本居中，如下图所示：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171019163206846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br></p><hr color="gray"><p></p>
<p></p><h3><strong>十四、简单的饼图</strong></h3><p></p>
<p></p><h4><em>解决方法：</em></h4><p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    border-radius: 50%;<br>    background-image: linear-gradient(to right,transparent 50%,#655 0);<br>    background-color: green;<br>}<br>.first::before{<br>    content:””;<br>    display: block;<br>    margin-left: 50%;<br>    height: 100%;<br>    border-radius: 0 100% 100% 0/50%;<br>    background-color: inherit;<br>    transform-origin: left;<br>    transform(0.1turn);<br>}<br></pre><br>首先为.first元素变成一个背景色为绿色的圆形；然后在圆形左边通过渐变设置一个棕色背景色的半圆形覆盖原先的背景色；现在的圆形是左半边是绿色的，右半边是棕色的；最后利用伪元素再在左半边设置一个颜色继承父元素的右半圆形，改变旋转中心，旋转0.1turn(即360度的10%)；但是如何设置一个动态旋转的饼图呢？如下：</p>
<p><pre><br>.first{<br>    margin: auto;<br>    position: relative;<br>    top: 50px;<br>    width: 300px;<br>    height: 300px;<br>    border-radius: 50%;<br>    background-image: linear-gradient(to right,transparent 50%,#655 0);<br>    background-color: green;<br>}<br>@keyframes spin{<br>    to {transform: rotate(.5turn);}<br>}<br>@keyframes bg{<br>    50%{background: #655;}<br>}<br>.first::before{<br>    content:””;<br>    display: block;<br>    margin-left: 50%;<br>    height: 100%;<br>    border-radius: 0 100% 100% 0/50%;<br>    background-color: inherit;<br>    transform-origin: left;<br>    animation: spin 3s linear infinite,<br>               bg 6s step-end infinite;<br>}<br></pre><br>这个代码的意思是为伪元素设置两个动画，第一个动画是在3s内将伪元素旋转至50%，然后从头开始再旋转；但是就是在从头开始旋转的那一刻，伪元素的背景色变成了棕色，因为第二个动画是在50%开始的，也就是第一个动画上一次结束的时候。这次就是原来渐变色背景的棕色加上伪元素旋转遮盖右半圆的棕色，在视觉上就是接着50%饼图的棕色继续叠加。等到第二个动画结束的时候，让第二个动画又重新开始，又正好切在了第一个动画开始的时间点，等到第一个动画进行的3s时即第二个动画的50%，又将伪元素变成棕色开始旋转。<code>step-end</code>的作用时让伪元素在50%变成棕色，而不是渐变成棕色。所以step-start也是可以的。如下图(静态)所示:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171019204011517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br>如何在HTML中直接输入一个数字就能得到相应比例的静态饼图呢？首先在HTML中应这样输入代码：</p>
<p><pre><br>&lt;div class=”first” animation-delay=”-20s”&gt;&lt;div&gt;<br></pre><br><code>-20s</code>会让动画直接跳转到20s处直接开始。所以我们除了利用<code>ainimation-play-state:paused</code>将伪元素设置成静态的动画，还必须将动画时间设置成100s，那么-20s也能很好的表示为20%，代码如下：</p>
<p><pre><br>.first{<br>    margin: auto;<br>    position: relative;<br>    top: 50px;<br>    width: 300px;<br>    height: 300px;<br>    border-radius: 50%;<br>    background-image: linear-gradient(to right,transparent 50%,#655 0);<br>    background-color: green;<br>}<br>@keyframes spin{<br>    to {transform: rotate(.5turn);}<br>}<br>@keyframes bg{<br>    50% {background: #655;}<br>}<br>.first::before{<br>    content:””;<br>    display: block;<br>    margin-left: 50%;<br>    height: 100%;<br>    border-radius: 0 100% 100% 0/50%;<br>    background-color: inherit;<br>    transform-origin: left;<br>    animation: spin 50s linear infinite,<br>               bg 100s step-end infinite;<br>    animation-play-state: paused;<br>    animation-delay: inherit;<br>}<br></pre><br>但是这里是伪元素有动画，而在HTML中又没有办法为伪元素设置<code>animation-delay</code>的属性，但是我们可以为伪元素设置<code>animation-delay:inherit</code>来继承父元素的属性。截图如下:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171019220105289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" height="50%"></div><br>除了用上面的方法外还可以使用svg方法，HTML代码如下：</p>
<p><pre><br>&lt;svg  width=”100” height=”100”&gt;<br>       &lt;circle r=”25” cx=”50” cy=”50”/&gt;<br>   &lt;/svg&gt;<br></pre><br>CSS代码如下:<br></p>
<p><pre><br>circle{<br>    fill: yellowgreen;<br>    stroke: #655;<br>    stroke-width: 50;<br>    stroke-dasharray: 0 158;<br>    animation: fillup 5s linear infinite;<br>}<br>@keyframes fillup{<br>    to{<br>        stroke-dasharray: 158 0;<br>    }<br>}<br>svg{<br>    transform: rotate(-90deg);<br>    border-radius: 50%;<br>    background-color: yellowgreen;<br>}<br></pre><br>以svg为底，以circle为旋转图；旋转的其实是circle的stroke，为stroke设置为svg的半径长度；既然svg有背景色，那为什么还要为circle设置fill呢？？因为circle要设置半径和圆心，那它就占有面积显示在svg上,如图：</p>
<p><div align="center"><br><img src="http://img.blog.csdn.net/20171019230201980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br></div><br>所以除了为svg设置背景色以外，因为不得不用到circle,所以还要为circle设置填充色；&gt;，所以除了为svg设置背景色以外，因为不得不用到circle,所以还要为circle设置填充色；这里要注意<code>stroke-dasharray: 0 158;</code>意思是宽度0，间隔158（158=2πr）；等到动画完成就是扇形宽度158，间隔为0；动画静态图如图所示</p>
<p><div align="center"><br><img src="http://img.blog.csdn.net/20171019230218284?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br></div><hr color="gray"></p>
<p></p><h3><strong>十五、单侧投影</strong></h3><p></p>
<p></p><h4>一、默认投影</h4><p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background-color: #006697;<br>    box-shadow: 3px 3px 6px  black;<br>}<br></pre><br>效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021142045053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>6px指的是模糊半径，但是太过浓重会不美观，如果给box-shadow作一点改变：</p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background-color: #006697;<br>    box-shadow: 3px 3px 6px  -3px black;<br>}<br></pre><br>就会得到下图，仔细观察下边和右边，还是能看到模糊的部分，通过为第四个参数（即扩张半径）指定负数，会剩下浅色的阴影部分就美观多了.<strong>但是要注意第四个参数的绝对值如果等于第三个参数，那么阴影就会消失。如果第四个参数小于第一或者第二个参数，那么除了浅色部分的阴影，还有一点深色的阴影，如果等于就只剩下浅色部分的阴影，大于浅色部分阴影会更不明显。</strong>如下图：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021142410578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p></p><h4>二、单侧投影</h4><p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background-color: #006697;<br>    box-shadow: 0px 3px 6px -2px black;<br>}<br></pre><br>这里为第四个参数设置的绝对值小一点，可以让图片看到明显一点的浅色阴影.第一个参数是水平阴影，第二个是垂直阴影。所以将第一个参数设为0的时候，就只剩下垂直的阴影；如果是第二个参数为0，第一个参数有数值，那么现在图片上看到的就是水平方向上的阴影；如图所示:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021145237017?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p></p><h4>三、双侧投影</h4><p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background-color: #006697;<br>    box-shadow: 5px 0px 6px -3px black,<br>                -5px 0px 6px -3px black;<br>}<br></pre><br>可以看出为水平方向（或者垂直方向）设置负值，就可以在左边（或者上边）设置阴影；如图所示:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021150155608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p></p><h4>四、四边阴影</h4><p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background-color: #006697;<br>    box-shadow: 0px 0px 8px  black;<br>}<br></pre><br>如下图所示:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021150630216?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>这里没有第四个参数，可以看到阴影颜色很浅；为第四个参数设置数值，就可以看到浓重的阴影部分；<hr color="gray"></p>
<p></p><h3><strong>十六、不规则投影</strong></h3><p></p>
<p></p><h4><em>问题:元素在有些情况下无法很好的设置阴影，即阴影不能紧贴着边框；情况如下:<br><br>1.元素用clip-path剪切形成的各种形状的元素；<br><br>2.元素的background-clip属性值不是border-box时；<br><br>3.元素的使用了伪元素；<br><br>4.几乎所有的折角效果；<br></em></h4><br>比如：<p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background-color: #006697;<br>    box-shadow: 0px 0px 8px 2px black;<br>}<br>.first:before{<br>    content:””;<br>    width: 0px;<br>    height: 0px;<br>    border: 50px solid;<br>    border-color: transparent  transparent transparent #006697;<br>    position: absolute;<br>    top: 100px;<br>    left: 300px;<br>}<br></pre><br>效果图如下,可以看到伪元素没有阴影:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021160115160?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p></p><h4><em>解决方法：使用<code>filter:blur() grayscale() drop-shadow()</code>方法。</em></h4><br>可以对上图使用<code>drop-shaadow()</code>方法，而不是<code>box-shadow</code>方法;有一点要注意的是:<strong><code>drop-shaadow()</code>不支持扩张半径(即第四个参数)，不支持inset关键字，不支持逗号分隔的多重阴影strong&gt;代码如下:<p></p>
<p><pre><br>filter:drop-shadow:0px 0px 8px black）;<br></pre><br>效果图如下所示:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021161235204?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><hr color="gray"></p>
<p></p><h3><strong>十七、染色效果</strong></h3><p></p>
<p></p><h4>第一种方法</h4><br>使用<code>filter:sepia()  saturate()  hue-rotate()可以改变滤镜颜色。sepia()会给图片覆盖一层褐色的滤镜，有一种古老照片的感觉，值为1-100；saturate()改变色相的饱和度，饱和度越高，视觉上颜色越亮，值为1-100；hue-rotate()时色相反转，0deg-360deg；<p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>}<br>img{<br>    width: 100%;<br>    height: 100%;<br>    filter: sepia(1) saturate(4) hue-rotate(295deg);<br>}<br></pre><br>得到如下图:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021175444916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p></p><h4>第二种方法</h4><p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background: hsl(335,100%,50%);<br>}<br>img{<br>    width: 100%;<br>    height: 100%;<br>    mix-blend-mode: luminosity;<br>}<br></pre></p>
<p></p><h4>第三种方法</h4><br>为父元素设置一张背景图，再为父元素设置background-blend-mode;<p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background-size: cover;<br>    background-color: hsl(335,100%,50%);<br>    background-blend-mode: luminosity;<br>    transition: .5s background-color;<br>}<br>.first:hover{<br>    background-color: transparent;<br>}<br></pre><hr color="gray"></p>
<p></p><h3><strong>十八、毛玻璃效果</strong></h3><p></p>
<p><pre><br>body{<br>    background-color: yellowgreen;<br>}<br>.first{<br>    width: 300px;<br>    height: 300px;<br>    margin: 0 auto;<br>    position: relative;<br>    top: 200px;<br>    background: hsla(0,0%,100%,.3);<br>}<br>.first::before{<br>    content: “”;<br>    top: 0;right: 0;bottom: 0;left: 0;<br>    position: absolute;<br>    background:url(“../1.jpg”) 0/cover;<br>    z-index: -1;<br>    filter: blur(20px);<br>}<br></pre><br>为父元素设置一层半透明背景，然后让子元素的<code>z-index:-1</code>放置在父元素的背后，让伪元素的背景从后面透出在前，制造出一种半透明的效果,而且这样的好处是，父元素的字体能清晰的显示出来；模糊的玻璃效果，还需要设置<code>blur(20px)</code>,但是四周也出现了模糊的阴影一样，如图:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021191612484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>这时可以为父元素添加<code>overflow:hidden</code>来消除边界的模糊:</p>
<p><pre><br>.first{<br>. . . . . .<br>overflow:hidden;<br>}<br>.first:before{<br>. . . . . .<br>}<br></pre><br>效果图如下:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021192328323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><hr color="gray"></p>
<p></p><h3><strong>十九、折角效果</strong></h3><p></p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background: #58a; /<em>回退样式</em>/</pre></p>
<pre><code>/*第一个linear-gradient设置了position为右上角，大小为2em 2em,指的是水平和垂直方向上都为2em，而第二个直接写在当中的（即指整个背景）,是指对角线的长度，所以为了让两者重合，必须以其中一个为标准，得出第二个对角线长度为1.5em*/

background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.4) 0) no-repeat 100% 0/2em 2em,linear-gradient(-135deg,transparent 1.5em,#58a 0);
</code></pre><p>}<br></p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021200344070?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>如果角度不止是45度，还有其他的角度，依然可以根据三角函数算出第一个linear-gradient中折角的长度和宽度（因为第一个linear-gradient的阴影长度是根据长度和宽度计算，而不是根据对角线的长度）。如下：</p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    background: #58a; /<em>回退样式</em>/</pre></p>
<pre><code>/*假设第二个对角线长度为1.5em,150deg让折角的角度为30-60-90*/

background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.4) 0) no-repeat 100% 0/3em 1.73em, linear-gradient(-150deg,transparent 1.5em,#58a 0);
</code></pre><p>}<br></p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021201814486?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>但是实际上，显示中是不能折成这样的折角的，为了让折角更逼真，如下设置:</p>
<p><pre><br>.first{<br>    width: 300px;<br>    height: 300px;<br>    margin: 0 auto;<br>    position: relative;<br>    top: 200px;<br>    background: #58a; /<em>回退样式</em>/<br>    background: linear-gradient(-150deg,transparent 1.5em,#58a 0);<br>}<br>.first::before{<br>    content: “”;<br>    position: absolute;<br>    top: 0;<br>    right: 0;<br>    background:linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.4) 0) no-repeat 100% 0;<br>    height: 3em;  /<em>height和width值互换了要注意</em>/<br>    width: 1.73em;<br>    transform-origin: bottom right;<br>    transform:translateY(-1.3em) rotate(-30deg) ; /<em>1.3=3-1.73</em>/<br>}<br></pre><br>这里我试过将<code>translateY</code>放在后面，但是没有如下图的效果，发生错位，可是放在前面就能实现这样的效果，原因未知，效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171021213140123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><hr color="gray"></p>
<p></p><h3><strong>二十七、文字突起效果</strong></h3><p></p>
<p><pre><br>.first{<br>    . . . . . .<br>    background: #809DB1;<br>    color: #ffc;<br>    text-shadow: 0 1px hsl(0,0%,85%),<br>                 0 2px hsl(0,0%,80%),<br>                 0 3px hsl(0,0%,75%),<br>                 0 4px hsl(0,0%,70%),<br>                 0 5px hsl(0,0%,65%);<br>                 0 5px 10px black;<br>}<br></pre><br>采用垂直层层递进的方法添加<code>text-shadow</code>可以使字体凸起效果更加真实.如图：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171025205202628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p><hr color="gray"></p>
<p></p><h3><strong>三十一、自定义复选框</strong></h3><br> <pre><br>input + label::before{<br>    content: “\a0”;<br>    display: inline-block;<br>    width: 16px;<br>    height: 16px;<br>    line-height: 16px;<br>    margin-right: 3px;<br>    border-radius: 3px;<br>    background: silver;<br>    text-align: center;<br>}<br> </pre><br> 首先利用伪元素，在<code>label</code>前添加一个框，要用到<code>width,height</code>所以将其设置为<code>iline-block</code>,<code>text-align</code>是为了选√时，√作为文字垂直居中。<code>line-height =height</code>是为了让选框垂直居中，不至于过于向上或向下，结果如下图:<br> <div align="center"><img src="http://img.blog.csdn.net/20171027203132694?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div>在选择的时候，只需要在<code>content</code>中增加√，以及背景色改变一下，代码如下:<br> <pre><br> . . . . . .<br> input:checked + label:before{<br>    content: “\2713”;<br>    background: yellowgreen;<br>}<br> </pre><br> 效果图如下：<br> <div align="center"><img src="http://img.blog.csdn.net/20171027204907728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br> 接下来要去掉默认的选框：<br> <pre><br> input{<br>    position: absolute;<br>    clip: rect(0,0,0,0);<br>}<br> </pre><br> <code>clip</code>使用时要注意在<code>position:absoute;和position:fixed</code>时才有效果。<code>react(top,right,bottom,left)</code>是指原元素距离上边距和左边距的四条边，裁剪后留下的部分，如果四个值都是0，那就是全部裁剪没有；效果图如下：<br> <div align="center"><img src="http://img.blog.csdn.net/20171027211829829?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><hr color="gray"><br> <h3><strong>三十四、滚动提示</strong></h3><p></p>
<p><pre><br>.first{<br>    width: 200px;<br>    height: 150px;<br>    overflow: auto;<br>    background:linear-gradient(white,white),<br>               radial-gradient(at top,rgba(0,0,0,.2),transparent 70%);<br>    background-repeat: no-repeat;<br>    background-size:100% 15px;<br>    background-attachment: local,scroll;<br>}<br></pre><br>假设是在一个<code>overflow:auto</code>的无序列表中，为列表的顶部设置渐变背景；第一层白色的线性渐变（实际上就是由上下两种白色渐变模拟形成高15px,宽100%白色背景色），并为线性渐变设置<code>background-attachment:local;</code>意思是让背景色随着内容的滚动而滚动；而被线性渐变遮挡的圆形渐变，因为<code>background-attachment:scroll;</code>不会随着内容的移动而移动而显示出来（<strong>对于可以滚动的元素如<code>overflow:scroll;overflow:auto;</code>设置<code>background-attachment:scroll;</code>,元素背景不会随着内容的滚动而滚动；<code>background-attachment</code>的值<code>scroll,local</code>相对于元素而言；<code>fixed</code>相对于视口而言。</strong>）,滚动和不滚动的效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171029201141987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><img src="http://img.blog.csdn.net/20171029201151724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><hr color="gray"></p>
<p></p><h3><strong>三十五、交互式图片对比控件</strong></h3><br><b>HTML代码如下：</b><p></p>
<p><pre><br>&lt;div class=”first”&gt;<br>       &lt;div&gt;<br>           &lt;img src=”1.jpg” alt=”before”&gt;<br>       &lt;/div&gt;<br>       &lt;img src=”2.jpg” alt=”after”&gt;<br>&lt;/div&gt;<br></pre><br><b>CSS代码如下：</b></p>
<p><pre><br>.first{<br>    position: relative;<br>    display: inline-block;<br>    width: 480px;<br>    height: 384px;<br>}<br>.first &gt; div{<br>    position: absolute;<br>    top: 0;<br>    bottom: 0;<br>    left: 0;<br>    width: 50%;<br>    max-width: 480px;<br>    overflow: hidden;<br>    resize: horizontal;<br>}<br>.first img{<br>    display: block;<br>}<br></pre><br>先为父元素设置<b>宽度和高度</b>，这里强制设定了<code>.first</code>元素为图片的宽度和高度；然后为<code>.first</code>设置<code>relative</code>,这是为了让<b>before</b>图片的容器可以相对于父元素（即<code>.first</code>）定位；<code>1.jpg</code>的容器设置了<code>absolute</code>,并且超出容器的<code>1.jpg</code>图片因为<code>overflow:hidden;</code>被隐藏；所以后面的<code>2.jpg</code>自动紧贴紧贴<code>1.jpg</code>，形成了一半一半不同亮度的图片（见下面效果图）；<code>resize: horizontal;</code>和<code>max-width: 480px;</code>是为了让<code>1.jpg</code>图片的容器宽度可以改变，从而可以更全面的对比两张照片，并且<code>1.jpg</code>容器的宽度最大不能超过480px;效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171029212639480?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171029212650024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>但是在图上可以看出，用以拉伸容器的标记并没有在图片上显示出来，这样用户会不知道容器是可以拉伸的，所以必须为<code>1.jpg</code>图片的容器设置一个明显的拉伸标志：</p>
<p><pre><br>. . . . . .<br>.first &gt;div::before{<br>    content: ‘’;<br>    position: absolute;<br>    bottom: 0;<br>    right: 0;<br>    width: 12px;<br>    height: 12px;<br>    padding: 5px;<br>    background: linear-gradient(-45deg,black 50%,transparent 0);<br>    background-clip: content-box;<br>    cursor: ew-resize;<br>}<br></pre><br>利用伪元素，设置一个宽和高都为12px,且定位在容器右下角的拉伸图标；用线性渐变做出一个三角形作为伪元素的背景；并且为了美观，这个伪元素距离右边和底边的距离为5px，同时为了不让线性渐变背景不填充内边距，将背景色的显示设置为内容区域,即<code>background-clip: content-box;</code>，同时给这个伪元素一个拉伸光标，即<code>cursor: ew-resize;</code>效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171029213605955?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><hr color="gray"></p>
<p></p><h3><strong>三十六、自适应内部元素</strong></h3><br><b>HTML代码</b><p></p>
<p><pre><br>&lt;figure class=”first”&gt;<br>       &lt;img src=”1.jpg” alt=”before”&gt;<br>       &lt;figcaption&gt;<br>            the hehjhf jfkdsfidhf sadauailjdksadih<br>            dhjashfjahf,hdsfihsdifhdsu,dfauhfuahfu.<br>        &lt;/figcaption&gt;<br>&lt;/figure&gt;<br></pre><br><b>CSS代码</b></p>
<p><pre><br>.first{<br>    border: 1px solid red;<br>}<br>figcaption{<br>    text-align: center;<br>}<br></pre><br>这样，因为父元素没有定宽度，所以父元素的宽度由其子元素的宽度决定；在这里，<code>figcaption</code>因为是块元素，所以宽度是屏幕宽度，父元素的宽度也会被拉长，效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171030113942698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>但是，如果给父元素的<code>width</code>加上<code>min-content</code>就让父元素的宽度由子元素的最大<b>内容宽度</b>决定；代码如下：</p>
<p><pre><br>.first{<br>    width: min-content;<br>    margin: auto;<br>    border: 1px solid red;<br>}<br>figcaption{<br>    text-align: center;<br>}<br></pre><br>再让<code>margin:auto;</code>我们就能让文字居中，更美观；<code>border</code>的作用是辅助作用，这里是为了可以更清楚看到宽度变小，效果图如下:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171030114646740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><b>关于<code>width</code>的属性，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width" target="_blank" rel="external">这个链接</a></b></p>
<p><hr color="gray"></p>
<p></p><h3><strong>三十六、精确控制表格列宽</strong></h3><br>再不设置<code>width</code>的前提下，单元格的宽度由其内的内容决定；表格的宽度由其单元格宽度决定,如:<br><br><b>HTML代码</b><p></p>
<p><pre><br>&lt;table&gt;<br>    &lt;tr&gt;<br>        &lt;td&gt;If we don’t…&lt;/td&gt;<br>        &lt;td&gt;specify a cell width, they will be assigned one that depends on their contents. Notice how the cell with the more content here is much wider.&lt;/td&gt;<br>     &lt;/tr&gt;<br>    &lt;tr&gt;<br>      &lt;td&gt;All rows take part in calculating the widths, not just the first one.&lt;/td&gt;<br>      &lt;td&gt;Notice how the dimensions here are different than the previous example.&lt;/td&gt;<br>    &lt;/tr&gt;<br>&lt;/table&gt;<br></pre><br><b>CSS代码</b></p>
<p><pre><br>table td{<br>    border: 1px solid gray;<br>}<br>table{<br>    border-collapse:collapse;<br>}<br></pre><br>效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171030125857953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>如果为单元格指定宽度：<br><br><b>HTML代码</b></p>
<p><pre><br>&lt;table&gt;<br>    &lt;tr&gt;<br>        &lt;td style=”width: 1000px”&gt;If we specify a width, it will not always be followed. I have a width of 1000px…&lt;/td&gt;<br>        &lt;td style=”width: 2000px”&gt;…and I have a width of 2000pxBecause there’s not enough space for 3000pxthey are reduced proportionally, to 33.3% and 66.6% of the total width.&lt;/td&gt;<br>    &lt;/tr&gt;<br>&lt;/table&gt;<br></pre><br>效果图如下:</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171030141143676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>如果为表格设置<code>table-layout:fixed;</code>意思是单元格的宽度有表格的宽度来决定，为表格指定一个宽度以后，单元格的宽度会平分表格的宽度;会满足如下：</p>
<p><pre><br>table td{<br>    border: 1px solid gray;<br>}<br>table{<br>    border-collapse:collapse;<br>    table-layout: fixed;<br>    width: 100%;<br>}<br></pre><br>效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171030142019538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div></p>
<p><hr color="gray"></p>
<p></p><h3><strong>四十一、紧贴底部的页脚</strong></h3><br><b>HTML代码</b><p></p>
<p><pre><br>&lt;header&gt;<br>    &lt;h1&gt;Site name&lt;/h1&gt;<br>&lt;/header&gt;<br>&lt;main&gt;<br>    &lt;input type=”checkbox” id=”contents” /&gt;&lt;label for=”contents”&gt;Toggle contents&lt;/label&gt;<br>    &lt;p&gt;t laborumer. Ham hock reprehenderit sint beef, sausage pig eiusmod t-bone shankle strip steak.&lt;/p&gt;<br>    &lt;p&gt;icken, cued lly pancetta pork chop. Pork  andouille deserunt alcatra irure prosciutto do.&lt;/p&gt;<br>    &lt;p&gt;ck exceptn velnkfurter et veniam dolore. Pig pork belly beef ribs kevin, doner exercitation magna esse shankle.&lt;/p&gt;<br>    &lt;p&gt;Proident erunt b fugiat landjaeger kevin pork chop beef ribs leberkas hamburger cillum turkey ut doner culpa.&lt;/p&gt;<br>&lt;/main&gt;<br>&lt;footer&gt;<br>    &lt;p&gt;© 2015 No rights reserved.&lt;/p&gt;<br>    &lt;p&gt;Made with ♥ by an anonymous pastafarian.&lt;/p&gt;<br>&lt;/footer&gt;<br></pre><br><b>CSS代码</b></p>
<p><pre><br>footer{<br>    background-color: black;<br>    color: white;<br>}<br></pre><br>如果只是对页脚中规中矩的设置一些样式，会得到以下效果图：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171030182938911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br>可以看出页脚因为上面内容区的高度小于视口的高度，所以页脚上升到了页面的中间;<br>为了防止这样的状况，添加以下代码：</p>
<p><pre><br>. . . . . .<br>body{<br>    display: flex;<br>    flex-flow: column;<br>    min-height: 100vh;<br>}<br>main{<br>    flex-grow: 1;<br>}<br></pre><br>为body元素添加的样式，使的<code>body</code>的最小高度为视口高度，然后其中的子元素按上到下的顺序排列；最重要的是为body中的子元素<code>main</code>设置<code>flex-grow: 1;</code>，<code>main</code>元素就会伸展;如果为所有的子元素都设置这个样式，那么子元素会等分设置了<code>display:table</code>的父元素；<br>同样的，如果其中一个子元素的值为2，另一个子元素的值为1，那么按比例来说，前一个元素的高度为后一个元素的2倍；本次代码的效果图如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20171030190401728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><hr color="gray"></p>
<p></p><h3><strong>四十三、逐帧动画</strong></h3><p></p>
<p><pre><br>@keyframes loader {<br>    to { background-position: -800px 0; }<br>}</pre></p>
<p>.loader {<br>    width: 100px; height: 100px;<br>    background: url(<a href="http://dabblet.com/img/loader.png" target="_blank" rel="external">http://dabblet.com/img/loader.png</a>) 0 0;<br>    animation: loader 1s infinite steps(8);<br>}<br><br><code>.loader</code>元素设置成只能容下一帧动画的宽度和高度；因为在<code>animation</code>中设置成了<code>steps(8)</code>就是将动画的-800px/8帧，每帧都会向左移动100像素,而且变成逐帧动画，所以不会有动画的间隙产生，所以不用设置<code>overflow:hidden</code>来隐藏超出部分的7张图片；</p>
<p><hr color="gray"></p>
<p></p><h3><strong>四十四、闪烁效果</strong></h3><br><b>第一种闪烁</b><p></p>
<p><pre><br>@keyframes blink-1 { 50% { color: transparent } }<br>.blink-smooth-1 {<br>    animation: 1s blink-1 3;<br>}<br></pre><br>上面样式设置了一个动画<code>blink-1</code>,每次动画都是1s完成，一共重复了3次动画；动画的效果是，在0.5s的时候字体颜色变透明，然后接下来的0.5s又从透明渐变到黑色；这样重复3次，视觉上又一种警醒的效果；<br><b>第二种闪烁</b></p>
<p><pre><br>@keyframes blink-2 { to { color: transparent } }<br>.blink-smooth-2 {<br>    animation: .5s blink-2 6;<br>    animation-direction: alternate;<br>}<br></pre><br>也是同样的效果，动画是每次0.5s就完成，即在0.5s之内直接变成透明；但是因为<code>animation-direction:alternate;</code>,所以第二次会反向从透明处变成黑色，而且因为次数较多，包括第二次，所以会又很平滑的渐变；如果动画循环的次数是1，虽然也会从透明变会黑色，但那是回到原来的样子，不是渐变，所以不平滑；<br><b>第三种闪烁</b></p>
<p><pre><br>@keyframes blink-1 { 50% { color: transparent } }<br>.blink {<br>    animation: 1s blink-1 3 steps(1);<br>}<br></pre><br>将动画50%状态处作为一帧；这个闪烁效果比较强硬；</p>
<p><hr color="gray"></p>
<p></p><h3><strong>四十五、打字动画</strong></h3><br>HTML代码<p></p>
<p><pre><br>&lt;h1&gt;CSS is awesome!&lt;/h1&gt;<br></pre><br>CSS代码</p>
<p><pre><br>@keyframes typing {<br>    from { width: 0 }<br>}<br>@keyframes caret {<br>    50% { border-right-color: transparent; }<br>}<br>h1 {<br>    font: bold 200% Consolas, Monaco, monospace;<br>    /<em>width: 8.25em;</em>/<br>    width: 15ch;<br>    white-space: nowrap;<br>    overflow: hidden;<br>    border-right: .05em solid;<br>    animation: typing 8s steps(15),<br>               caret 1s steps(1) infinite;<br>}<br></pre><br>这个动画的过程是让<code>h1</code>的宽度从0开始到正好显示其中所有字体的宽度，每显示一次宽度都是一帧；<code>ch</code>是每个字符的宽度，由HTML代码部分可以看到，包括空格部分，总共有15个字符；所以将宽度设置为15ch；如果将宽度设置在动画中，即添加<code>to:{width:15ch;}</code><b>那么结果是动画结束后,因为要变成没有动画时的原来样式</b>，所以<code>h1</code>的宽度变成填充整个父元素的宽度，右边框的闪烁效果也会消失，因为原来的网页在没有动画时的样式就是这样的；<b>所以把最终宽度从样式里删除，就会保留到动画的最后结果</b>；右边宽的闪烁也会一直持续；再看右边框的动画样式，在50%的时候是透明的，因为每一次动画都是一帧，所以闪烁会非常生硬，直接从黑到白，但是却非常符合光标的闪烁；右边框 因为宽度的逐帧增加而出现，从而出现闪烁；但是宽度增加的时候，但是一旦有了宽度，如果没有设置<code>overflow:hidden;</code>,那么字体会溢出而直接将剩余字体显示出来，这样宽度增加而显示字体的效果就没有了；同时，如果没有<code>white-space:nowrap</code>，那么从零开始的时候，因为宽度没到最终值，所以直接在空白出打断，一开始是三行同时打字；<hr color="gray"></p>
<p></p><h3><strong>四十六、状态平滑的的动画</strong></h3><br>HTML代码<p></p>
<p><pre><br>&lt;div class=”panoramic”&gt;&lt;/div&gt;<br></pre><br>CSS代码</p>
<p><pre><br>@keyframes panoramic {<br>    to { background-position: 100% 0; }<br>}</pre></p>
<p>.panoramic {<br>    width: 150px; height: 150px;<br>    background: url(‘<a href="http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg" target="_blank" rel="external">http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg</a>‘);<br>    background-size: auto 100%;<br>    animation: panoramic 10s linear infinite alternate;<br>    animation-play-state: paused;<br>}</p>
<p>.panoramic:hover, .panoramic:focus {<br>    animation-play-state: running;<br>}<br><br>为元素设置一个比背景图片小的宽高，当作一个窗口；再将背景图片的宽度设置<code>auto</code>用来动画；当图片上没有鼠标悬浮的时候，动画是暂停的，有悬浮的时候动画是进行的；这个动画啊的效果是背景图片的位置从左移动右边；</p>
<p><hr color="gray"></p>
<p></p><h3><strong>四十七、沿环形路径平移的动画</strong></h3><br><b>HTML代码</b><p></p>
<p><pre><br>&lt;div class=”path”&gt;<br>        &lt;img src=”<em>*</em>.jpg” class=”avatar” /&gt;<br>&lt;/div&gt;<br></pre><br><b>CSS代码</b></p>
<p><pre><br>@keyframes spin {<br>    to {<br>        transform: rotate(1turn);<br>    }<br>}<br> @keyframes spin-reverse{<br>    from {<br>        transform: rotate(1turn);<br>    }<br>}</pre></p>
<p>.avatar {<br>    display: block;<br>    width: 50px;<br>    margin:auto calc(50% - 25px);<br>    border-radius: 50%;<br>    animation: spin 3s infinite linear;<br>}<br>.path {<br>    width: 300px; height: 300px;<br>    margin: 100px auto;<br>    border-radius: 50%;<br>    background: #fb3;<br>    animation: spin-reverse 3s infinite linear;<br>    transform-origin: 50% 150px;<br>}<br><br>代码中父元素<code>.path</code>逆时针旋转360度，旋转中心为圆中心；子元素<code>.avatar</code>先将其位置定在父元素顶部中点（利用<code>margin</code>）,因为父元素转动的时候，子元素也会转动，然后为了让图片保持不动，让其自身顺时针旋转360度，来抵消父元素旋转带来的自身旋转；</p>
</code></strong>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/16/html笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hangbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wobenng的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/16/html笔记/" itemprop="url">html笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-16T21:55:58+08:00">
                2017-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://img.blog.csdn.net/20171016190854758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="100%" height="100%"></p>
<p><div align="center"><b>HTML 元素</b></div></p>
<p></p><p><strong>1.空元素:</strong>没有内容的元素,没有结束标签.</p><p></p>
<p></p><p><strong>2.替换元素:</strong>元素可替换内容部分并非由文档内容直接表示.如<code>&lt;img&gt;</code>标签的图片就是由文档之外提供的</p><p></p>
<p></p><p><strong>3.<code>&lt;iframe&gt;</code>:</strong>将其他Web文档嵌入到当前文档中;它有以下属性:<br></p>
<p><ul></ul></p>
<p><li><code>frameborder</code>:绘制边框,值为0则没有边框.</li></p>
<p><li><code>src</code>:嵌入路径</li></p>
<p><li><code>width</code>和<code>height</code>规定<code>&lt;iframe&gt;</code>的宽度和高度.</li><br><br></p><p></p>
<p><hr color="gray"><br>未完待续</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/16/CSS笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hangbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wobenng的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/16/CSS笔记/" itemprop="url">CSS笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-16T14:06:33+08:00">
                2017-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h3><strong>八、CSS Tricks Yin Yang 笔记</strong></h3><p></p>
<p><hr></p>
<p></p><h3><a href="https://css-tricks.com/examples/ShapesOfCSS/" target="_blank" rel="external">原文链接</a></h3><br>首先要设置上下颜色不一样的两个长方形：<p></p>
<pre>
.yin-yang{
    width: 96px;
    height: 48px;
    background: #eee;
    border-color: red;
    border-style: solid;
    border-width: 2px 2px 50px 2px;
}
</pre>
宽度是高度的一半，将长方形的背景色设置为<code>background: #eee;</code>下半部分的颜色是直接将<code>border-bottom</code>设置成50px,视觉上就又了两个高度和宽度都一样的长方形（因为50px的下边框-2px的边框粗细=48px）。如图：
<div align="center"><img src="http://img.blog.csdn.net/20171024211957430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div>
接着将图形变成上下两个颜色的圆形，添加以下：
<pre>
.yin-yang{
    .  .  .  .  .  .
    border-radius: 50%;
}
</pre>
如下图所示:
<div align="center"><img src="http://img.blog.csdn.net/20171024212329112?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div>
利用伪元素画图中的中心镂空的圆形：
<pre>
.yin-yang:before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    background: #eee;
    border: 18px solid red;
    border-radius: 50%;
    width: 12px;
    height: 12px;
}
.yin-yang{
    . . . . . .
    position: relative;
}
</pre>
利用绝对定位将伪元素定位到距离左边0px（<code>left:0px</code>）,距离顶部50%(<code>top:50%</code>)的地方，<b>.yinyang视觉上的高度超过48px，但是那是包括border-bottom的高度；这里50%要注意是相对.yinyang48px的高度而言的。</b>
要将两个伪元素圆形左右正好平均分布在父元素宽度上，就要使每个伪元素圆形的宽度为48px(不用减去边框的宽度，因为<code>left:0px;</code>),可以看出，18*2+12=48；
需要将伪元素的高度设为此时是相对于父元素的，所以.yiyang设置为相对定位(<code>position: relative;</code>)。如图：
<div align="center"><img src="http://img.blog.csdn.net/20171024214136918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div>
接下来用同样的方法将右边的伪元素圆形也放上去:
<pre>
.yin-yang:after {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    background: red;
    border: 18px solid #eee;
    border-radius:50%;
    width: 12px;
    height: 12px;
}
</pre>
如图所示:
<div align="center"><img src="http://img.blog.csdn.net/20171024214458163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29iZW5uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div>
如果需要啊动态的yinyang图，需要加上以下代码：
<pre>
. . . . . .
.rotate {
    animation: 5s linear infinite rotate;
    transform-origin: 50% 50%;
  }

 @keyframes rotate {
    from {
      transform: rotate(0deg)
    }
    to {
      transform: rotate(360deg)
    }
}
</pre>
<b>完整代码如下:</b>
<pre>
.yin-yang {
    width: 96px;
    height: 48px;
    background: #eee;
    border-color: red;
    border-style: solid;
    border-width: 2px 2px 50px 2px;
    border-radius: 50%;
    position: relative;
}
.yin-yang:before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    background: #eee;
    border: 18px solid red;
    border-radius: 50%;
    width: 12px;
    height: 12px;
}

.yin-yang:after {
    content: "";
    position: absolute;
    top: 50%;
    right: 0;
    background: red;
    border: 18px solid #eee;
    border-radius:100%;
    width: 12px;
    height: 12px;
}
.rotate {
    animation: 5s linear infinite rotate;
    transform-origin: 50% 50%;
  }

 @keyframes rotate {
    from {
      transform: rotate(0deg)
    }
    to {
      transform: rotate(360deg)
    }
}
</pre>












          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hangbin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hangbin</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
